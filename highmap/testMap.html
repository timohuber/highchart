<script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
<script src="https://code.highcharts.com/maps/highmaps.js"></script>
<script src="https://code.highcharts.com/mapdata/custom/world.js"></script>

<div id="container"></div>

<button id="btn">increase</button>

<button id="btn1">reset</button>

<script>
    Highcharts.Axis.prototype.beforePadding = function () {
        var axis = this,
            axisLength = this.len,
            chart = this.chart,
            pxMin = 0,
            pxMax = axisLength,
            isXAxis = this.isXAxis,
            dataKey = isXAxis ? 'xData' : 'yData',
            min = this.min,
            extremes = {},
            smallestSize = Math.min(chart.plotWidth, chart.plotHeight),
            zMin = Number.MAX_VALUE,
            zMax = -Number.MAX_VALUE,
            range = this.max - min,
            transA = axisLength / range,
            activeSeries = [],
            pInt = Highcharts.pInt,
            H = Highcharts,
            pick = Highcharts.pick,
            arrayMin = H.arrayMin,
            arrayMax = H.arrayMax,
            isNumber = H.isNumber;
        console.log(axis);
        // Handle padding on the second pass, or on redraw
        this.series.forEach(function (series) {
            var seriesOptions = series.options,
                zData;
            if (
                series.bubblePadding &&
                (series.visible || !chart.options.chart.ignoreHiddenSeries)
            ) {
                // Correction for #1673
                axis.allowZoomOutside = true;

                // Cache it
                activeSeries.push(series);

                if (isXAxis) {
                    // because X axis is evaluated first

                    // For each series, translate the size extremes to pixel values
                    ['minSize', 'maxSize'].forEach(function (prop) {
                        var length = seriesOptions[prop],
                            isPercent = /%$/.test(length);

                        length = pInt(length);
                        extremes[prop] = isPercent
                            ? (smallestSize * length) / 100
                            : length;
                    });
                    series.minPxSize = extremes.minSize;
                    // Prioritize min size if conflict to make sure bubbles are
                    // always visible. #5873
                    series.maxPxSize = Math.max(
                        extremes.maxSize,
                        extremes.minSize
                    );

                    // Find the min and max Z
                    zData = series.zData.filter(H.isNumber);
                    if (zData.length) {
                        // #1735
                        zMin = pick(
                            seriesOptions.zMin,
                            Math.min(
                                zMin,
                                Math.max(
                                    arrayMin(zData),
                                    seriesOptions.displayNegative === false
                                        ? seriesOptions.zThreshold
                                        : -Number.MAX_VALUE
                                )
                            )
                        );
                        zMax = pick(
                            seriesOptions.zMax,
                            Math.max(zMax, arrayMax(zData))
                        );
                    }
                }
            }
        });

        activeSeries.forEach(function (series) {
            var data = series[dataKey],
                i = data.length,
                radius;

            if (isXAxis) {
                series.getRadii(zMin, zMax, series);
            }
            if (range > 0) {
                while (i--) {
                    if (
                        isNumber(data[i]) &&
                        axis.dataMin <= data[i] &&
                        data[i] <= axis.dataMax
                    ) {
                        radius = series.radii[i];
                        pxMin = Math.min(
                            (data[i] - min) * transA - radius,
                            pxMin
                        );
                        pxMax = Math.max(
                            (data[i] - min) * transA + radius,
                            pxMax
                        );
                    }
                }
            }
        });
    };

    let maxSize = 50;
    let minSize = 4;

    $.getJSON(
        'https://cdn.jsdelivr.net/gh/highcharts/highcharts@v7.0.0/samples/data/world-population.json',
        function (data) {
            Highcharts.mapChart('container', {
                chart: {
                    map: 'custom/world',
                },

                series: [
                    {
                        enableMouseTracking: false,
                    },
                    {
                        type: 'mapbubble',
                        joinBy: ['iso-a3', 'code3'],
                        data: data,
                        minSize: minSize,
                        maxSize: maxSize,
                    },
                ],
            });
        }
    );

    let btn = document.getElementById('btn'),
        btn1 = document.getElementById('btn1');

    btn.addEventListener('click', function () {
        maxSize += 50;

        $('#container').highcharts().series[1].update({
            maxSize: maxSize,
        });
        console.log(maxSize);
    });

    btn1.addEventListener('click', function () {
        maxSize = 50;
        $('#container').highcharts().series[1].update({
            maxSize: maxSize,
        });
        console.log(maxSize);
    });
</script>
